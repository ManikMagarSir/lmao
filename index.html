<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Forest World - Enhanced Models</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a0f0a; font-family: 'Outfit', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui { position: fixed; top: 24px; left: 24px; z-index: 100; pointer-events: none; }
        #mode { color: #7fdb8a; font-size: 13px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 8px; padding: 8px 16px; background: rgba(10, 25, 15, 0.85); border: 1px solid rgba(127, 219, 138, 0.3); border-radius: 4px; backdrop-filter: blur(8px); display: inline-block; box-shadow: 0 4px 12px rgba(0,0,0,0.5); transition: opacity 0.3s; }
        #coords { color: rgba(255,255,255,0.8); font-size: 12px; font-weight: 500; background: rgba(10, 25, 15, 0.7); padding: 4px 12px; border-radius: 4px; display: inline-block; margin-left: 10px; transition: opacity 0.3s; }
        
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 100; opacity: 0; transition: opacity 0.1s; }
        #crosshair.visible { opacity: 0.9; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #fff; border-radius: 1px; box-shadow: 0 0 8px rgba(127, 219, 138, 0.8); }
        #crosshair::before { width: 16px; height: 2px; left: -8px; top: -1px; }
        #crosshair::after { width: 2px; height: 16px; left: -1px; top: -8px; }
        
        #compass { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 200px; height: 30px; background: rgba(0,0,0,0.4); border-radius: 15px; overflow: hidden; z-index: 100; border: 2px solid rgba(255,255,255,0.3); }
        #compassNeedle { position: absolute; width: 4px; height: 100%; background: linear-gradient(to bottom, #ff4444 40%, #fff 40%, #fff 60%, #444 60%); left: 50%; transform: translateX(-50%); transition: transform 0.1s; }
        #compass::before { content: 'N'; position: absolute; left: 5px; top: 50%; transform: translateY(-50%); color: #ff4444; font-size: 10px; font-weight: bold; }
        #compass::after { content: 'S'; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #666; font-size: 10px; font-weight: bold; }
        
        #controls { position: fixed; bottom: 24px; left: 24px; color: rgba(255,255,255,0.7); font-size: 13px; font-weight: 500; z-index: 100; display: flex; flex-direction: column; gap: 8px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); transition: opacity 0.3s; }
        .control-key { display: inline-block; padding: 2px 8px; background: rgba(255,255,255,0.15); border-radius: 3px; color: #7fdb8a; margin-right: 8px; font-weight: 700; border: 1px solid rgba(127, 219, 138, 0.3); width: 55px; text-align: center; }
        
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0f0a; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.5s; }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 { color: #7fdb8a; font-size: 32px; font-weight: 700; letter-spacing: 6px; margin-bottom: 24px; text-shadow: 0 0 20px rgba(127, 219, 138, 0.5); }
        .loader { width: 250px; height: 4px; background: rgba(127, 219, 138, 0.2); border-radius: 2px; overflow: hidden; }
        .loader-bar { width: 0%; height: 100%; background: #7fdb8a; transition: width 0.3s ease-out; box-shadow: 0 0 10px rgba(127, 219, 138, 0.8); }
        
        #click-to-start { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 15, 10, 0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 999; cursor: pointer; transition: opacity 0.3s; }
        #click-to-start.hidden { opacity: 0; pointer-events: none; }
        #click-to-start h2 { color: #fff; font-size: 28px; font-weight: 700; letter-spacing: 2px; margin-bottom: 12px; }
        #click-to-start p { color: rgba(255,255,255,0.6); font-size: 15px; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        #minimap { position: fixed; bottom: 24px; right: 24px; width: 150px; height: 150px; background: rgba(10, 25, 15, 0.85); border: 2px solid rgba(127, 219, 138, 0.4); border-radius: 50%; z-index: 100; pointer-events: none; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.6); transition: opacity 0.3s; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        #credits-banner { position: fixed; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 11px; z-index: 100; pointer-events: none; letter-spacing: 1px; text-shadow: 0 1px 4px rgba(0,0,0,0.8); }
        #credits-banner span { color: #7fdb8a; font-weight: 700; }

        #spawn-effect { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,100,50,0.6) 0%, transparent 70%); pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 998; mix-blend-mode: screen; }
        #spawn-effect.active { opacity: 1; animation: meteorFall 2s ease-out forwards; }
        @keyframes meteorFall { 0% { transform: scale(0.1); opacity: 1; background: radial-gradient(circle, rgba(255,200,100,0.8) 0%, transparent 50%); } 30% { background: radial-gradient(circle, rgba(255,150,50,0.6) 0%, transparent 60%); } 70% { background: radial-gradient(circle, rgba(255,80,30,0.5) 0%, transparent 70%); } 100% { transform: scale(3); opacity: 0; background: radial-gradient(circle, rgba(127,219,138,0.3) 0%, transparent 80%); } }

        body.spawning #ui, body.spawning #controls, body.spawning #minimap { opacity: 0; }
        
        /* Mobile Controls */
        #mobile-controls { display: none; position: fixed; bottom: 0; left: 0; right: 0; padding: 20px; z-index: 100; pointer-events: none; }
        @media (max-width: 768px), (pointer: coarse) {
            #mobile-controls { display: flex; justify-content: space-between; align-items: flex-end; }
            #controls, #minimap { display: none; }
        }
        .mobile-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.15); border: 2px solid rgba(127,219,138,0.5); border-radius: 50%; pointer-events: auto; backdrop-filter: blur(5px); }
        .mobile-btn:active { background: rgba(127,219,138,0.4); }
        .mobile-dpad { display: grid; grid-template-columns: repeat(3, 50px); gap: 5px; }
        .mobile-dpad .mobile-btn { width: 50px; height: 50px; }
        .mobile-actions { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        .mobile-action-btn { width: 70px; height: 70px; border-radius: 50%; }
        .mobile-action-btn.jump { background: rgba(127,219,138,0.3); }
        .mobile-action-btn.sprint { background: rgba(255,150,50,0.3); }
    </style>
</head>
<body>
    <div id="loading">
        <h1>GENERATING WORLD</h1>
        <div class="loader"><div class="loader-bar" id="loader-bar"></div></div>
    </div>
    
    <div id="click-to-start" class="hidden">
        <h2>Click to Enter World</h2>
        <p>Pointer lock is required for camera controls</p>
    </div>
    
    <div id="ui">
        <div id="mode">First Person</div>
        <div id="coords">X: 0 | Z: 0</div>
        <div id="compass"><div id="compassNeedle"></div></div>
    </div>
    <div id="crosshair"></div>
    <div id="controls">
        <span><span class="control-key">WASD</span> Move</span>
        <span><span class="control-key">SHIFT</span> Sprint</span>
        <span><span class="control-key">SPACE</span> Jump</span>
        <span><span class="control-key">C</span> Toggle Camera</span>
    </div>
    <div id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>
    
    <div id="credits-banner">This prototype was made by <span>Manik Magar</span> and <span>Aadarsha K.C</span> with HTML, CSS, JS and THREE.JS</div>
 
    <div id="mobile-controls">
        <div class="mobile-dpad">
            <div></div>
            <button class="mobile-btn" id="btn-w">W</button>
            <div></div>
            <button class="mobile-btn" id="btn-a">A</button>
            <div></div>
            <button class="mobile-btn" id="btn-d">D</button>
            <div></div>
            <button class="mobile-btn" id="btn-s">S</button>
        </div>
        <div class="mobile-actions">
            <button class="mobile-btn mobile-action-btn sprint" id="btn-shift">SPRINT</button>
            <button class="mobile-btn mobile-action-btn jump" id="btn-space">JUMP</button>
        </div>
    </div>

    <div id="spawn-effect"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // ============ CONFIGURATION ============
        const CONFIG = {
            chunkSize: 120,          
            chunkRes: 24,            
            renderDist: 4,           
            waterLevel: 4,
            gravity: -30,
            playerSpeed: 12,
            sprintMultiplier: 1.8,
            jumpForce: 16, 
            playerHeight: 1.8,
            playerRadius: 0.45,
            spawnPoint: { x: 0, z: 0 },
            maxTreesPerChunk: 60, 
            maxRocksPerChunk: 15,
            maxHutsPerChunk: 2,
            cycleDuration: 600
        };

        let scene, camera, renderer, water, skybox, fireflies, playerModelData, spawnAltar;
        let player = {
            position: new THREE.Vector3(CONFIG.spawnPoint.x, 0, CONFIG.spawnPoint.z),
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: false, yaw: Math.PI, pitch: 0,
            isSpawning: true, spawnTimer: 0, 
            walkCycle: 0, bobAmount: 0
        };
        let keys = {}; let isFirstPerson = true; let isPointerLocked = false;
        let clock = new THREE.Clock(); let minimapCtx;
        
        const activeChunks = new Map();
        const chunkQueue = [];
        const chunkPool = [];
        const activeColliders = []; 
        const mobs = [];

        // Shared Materials & Geometries
        let terrainMat, treeMat, leavesMat, rockMat, hutMat;
        let trunkGeo, pineGeo, oakGeo, acaciaGeo, rockGeo, hutGeo;

        function updateLoading(percent) {
            const bar = document.getElementById('loader-bar');
            if (bar) bar.style.width = percent + '%';
        }

        // ============ ADVANCED MAP GENERATION NOISE ============
        class AdvancedNoise {
            constructor(seed = 0) { this.seed = seed; }
            noise2D(x, z) {
                const s = Math.sin(x * 12.9898 + z * 78.233 + this.seed) * 43758.5453;
                return s - Math.floor(s);
            }
            smooth(x, z, scale) {
                const sx = x / scale, sz = z / scale;
                const ix = Math.floor(sx), iz = Math.floor(sz);
                const fx = sx - ix, fz = sz - iz;
                const v00 = this.noise2D(ix, iz), v10 = this.noise2D(ix + 1, iz);
                const v01 = this.noise2D(ix, iz + 1), v11 = this.noise2D(ix + 1, iz + 1);
                const u = fx * fx * (3 - 2 * fx); const v = fz * fz * (3 - 2 * fz);
                const i1 = THREE.MathUtils.lerp(v00, v10, u); const i2 = THREE.MathUtils.lerp(v01, v11, u);
                return THREE.MathUtils.lerp(i1, i2, v);
            }
            fbm(x, z, octaves = 4, persistence = 0.5, scale = 100) {
                let total = 0, amplitude = 1, frequency = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    let nx = x * frequency; let nz = z * frequency;
                    let rx = nx * 0.8 - nz * 0.6; let rz = nx * 0.6 + nz * 0.8;
                    total += this.smooth(rx, rz, scale) * amplitude;
                    maxValue += amplitude; amplitude *= persistence; frequency *= 2;
                }
                return total / maxValue;
            }
            ridged(x, z, octaves = 4, persistence = 0.5, scale = 100) {
                let total = 0, amplitude = 1, frequency = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    let nx = x * frequency; let nz = z * frequency;
                    let rx = nx * 0.8 - nz * 0.6; let rz = nx * 0.6 + nz * 0.8;
                    let n = this.smooth(rx, rz, scale);
                    n = 1.0 - Math.abs(n * 2.0 - 1.0); n *= n; 
                    total += n * amplitude;
                    maxValue += amplitude; amplitude *= persistence; frequency *= 2;
                }
                return total / maxValue;
            }
        }
        const mapNoise = new AdvancedNoise(9999); 

        function getTerrainHeight(x, z) {
            let base = mapNoise.fbm(x, z, 4, 0.4, 150) * 35;
            let mountainMask = mapNoise.fbm(x + 5000, z - 5000, 3, 0.5, 500);
            mountainMask = Math.max(0, mountainMask - 0.4) * 2.5; 
            let mountains = mapNoise.ridged(x, z, 5, 0.5, 300) * 180;
            base += mountains * mountainMask;
            let ravineNoise = mapNoise.ridged(x - 2000, z + 2000, 4, 0.5, 400);
            let valley = (1.0 - ravineNoise); 
            if (valley > 0.6) {
                let depth = (valley - 0.6) * 4.0; 
                base -= Math.pow(depth, 2) * 50;
            }
            return base;
        }

        function getTerrainNormal(x, z) {
            const eps = 0.5;
            const L = getTerrainHeight(x - eps, z); const R = getTerrainHeight(x + eps, z);
            const D = getTerrainHeight(x, z - eps); const U = getTerrainHeight(x, z + eps);
            return new THREE.Vector3(L - R, eps * 2, D - U).normalize();
        }

        // ============ INITIALIZATION ============
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x7ec0ee); 
            scene.fog = new THREE.FogExp2(0x7ec0ee, 0.005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            createLighting();
            setupSharedMaterials();
            createInfiniteWater();
            createInfiniteSkybox();
            createFireflies();
            createWeatherSystem();
            createButterfliesAndPollen();
            
            playerModelData = createPlayerModel();
            // createSpawnAltar();
            createMobs();

            setupEvents();
            initMinimap();
            createLandmarks();
            forceLoadChunks(Math.floor(CONFIG.spawnPoint.x / CONFIG.chunkSize), Math.floor(CONFIG.spawnPoint.z / CONFIG.chunkSize));
            
            // Generate random spawn point avoiding mountains and water
            let validSpawn = false;
            let attempts = 0;
            while (!validSpawn && attempts < 200) {
                const sx = (Math.random() - 0.5) * 400;
                const sz = (Math.random() - 0.5) * 400;
                const height = getTerrainHeight(sx, sz);
                // Spawn between water level + 2 and height < 50 (avoid mountains and water)
                if (height > CONFIG.waterLevel + 2 && height < 50) {
                    CONFIG.spawnPoint = { x: sx, z: sz };
                    validSpawn = true;
                }
                attempts++;
            }
            // Fallback if no valid spot found
            if (!validSpawn) {
                CONFIG.spawnPoint = { x: 30, z: 30 };
            }
            
            // Set initial spawn position (will be assembled from falling parts)
            const spawnHeight = getTerrainHeight(CONFIG.spawnPoint.x, CONFIG.spawnPoint.z);
            player.position.set(CONFIG.spawnPoint.x, spawnHeight + CONFIG.playerHeight, CONFIG.spawnPoint.z);

            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('click-to-start').classList.remove('hidden');
            }, 800);
        }

        function createLighting() {
            scene.add(new THREE.AmbientLight(0x4a6a7a, 0.2));
            const hemi = new THREE.HemisphereLight(0x7ec0ee, 0x1a2a1a, 0.4);
            scene.add(hemi); scene.userData.hemi = hemi;

            const sun = new THREE.DirectionalLight(0xfff0dd, 1.2);
            sun.castShadow = true; sun.shadow.mapSize.set(512, 512);
            sun.shadow.camera.near = 10; sun.shadow.camera.far = 200;
            const d = 120;
            sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
            sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
            sun.shadow.bias = -0.001;
            scene.add(sun); scene.userData.sun = sun;

            const moon = new THREE.DirectionalLight(0x88bbff, 0.0);
            moon.castShadow = true; moon.shadow.mapSize.set(1024, 1024);
            moon.shadow.camera.near = 10; moon.shadow.camera.far = 400;
            moon.shadow.camera.left = -d; moon.shadow.camera.right = d;
            moon.shadow.camera.top = d; moon.shadow.camera.bottom = -d;
            moon.shadow.bias = -0.001;
            scene.add(moon); scene.userData.moon = moon;

            // Create visible sun mesh
            const sunMesh = new THREE.Mesh(
                new THREE.SphereGeometry(15, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffdd44 })
            );
            scene.add(sunMesh); scene.userData.sunMesh = sunMesh;

            // Create visible moon mesh
            const moonMesh = new THREE.Mesh(
                new THREE.SphereGeometry(10, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xdddddd })
            );
            scene.add(moonMesh); scene.userData.moonMesh = moonMesh;
        }

        // ============ COMPOSITE GEOMETRIES ============
        function setupSharedMaterials() {
            terrainMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.02 });
            treeMat = new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 1.0 });
            leavesMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, flatShading: true }); 
            rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9, flatShading: true });

            // Trunk
            trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 4, 5); 
            trunkGeo.translate(0, 2, 0); 
            
            // Pine (3 Cones)
            const p1 = new THREE.ConeGeometry(2.5, 4, 6); p1.translate(0, 3, 0);
            const p2 = new THREE.ConeGeometry(2.0, 3, 6); p2.translate(0, 5, 0);
            const p3 = new THREE.ConeGeometry(1.5, 2.5, 6); p3.translate(0, 6.5, 0);
            pineGeo = BufferGeometryUtils.mergeGeometries([p1, p2, p3]);

            // Oak (Clusters of Dodecahedrons)
            const o1 = new THREE.DodecahedronGeometry(2.2, 1); o1.translate(0, 4, 0);
            const o2 = new THREE.DodecahedronGeometry(1.8, 1); o2.translate(1.5, 4.5, 0);
            const o3 = new THREE.DodecahedronGeometry(1.8, 1); o3.translate(-1.5, 4.5, 0);
            const o4 = new THREE.DodecahedronGeometry(1.8, 1); o4.translate(0, 4.5, 1.5);
            const o5 = new THREE.DodecahedronGeometry(1.8, 1); o5.translate(0, 4.5, -1.5);
            const o6 = new THREE.DodecahedronGeometry(1.5, 1); o6.translate(0, 6, 0);
            oakGeo = BufferGeometryUtils.mergeGeometries([o1, o2, o3, o4, o5, o6]);

            // Acacia (Flat Umbrellas)
            const a1 = new THREE.CylinderGeometry(2.5, 2.5, 0.5, 6); a1.translate(0, 4.5, 0);
            const a2 = new THREE.CylinderGeometry(2, 2, 0.5, 6); a2.translate(2, 4.2, 1);
            const a3 = new THREE.CylinderGeometry(2.2, 2.2, 0.5, 6); a3.translate(-1.5, 4.8, -1);
            acaciaGeo = BufferGeometryUtils.mergeGeometries([a1, a2, a3]);

            rockGeo = new THREE.DodecahedronGeometry(1, 0);

            // Hut (Small wooden structure with roof)
            hutMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });
            const hutBase = new THREE.BoxGeometry(3, 2.5, 3);
            hutBase.translate(0, 1.25, 0);
            const hutRoof = new THREE.ConeGeometry(2.5, 2, 4);
            hutRoof.translate(0, 3.5, 0);
            hutRoof.rotateY(Math.PI / 4);
            hutGeo = BufferGeometryUtils.mergeGeometries([hutBase, hutRoof]);
        }

        function createSpawnAltar() {
            const altarGroup = new THREE.Group();
            
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x4a4a5a, roughness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(4, 4.5, 0.5, 16), baseMat);
            base.position.y = 0.25; base.receiveShadow = true; altarGroup.add(base);
            
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x6a6a7a, roughness: 0.7 });
            const positions = [[3, 0, 0], [-3, 0, 0], [0, 0, 3], [0, 0, -3]];
            positions.forEach(pos => {
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 3, 8), pillarMat);
                pillar.position.set(...pos); pillar.position.y = 1.5; pillar.castShadow = true;
                altarGroup.add(pillar);
                
                const rune = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), new THREE.MeshStandardMaterial({ color: 0x7fdb8a, emissive: 0x7fdb8a, transparent: true, opacity: 0.8 }));
                rune.position.y = 3; rune.rotation.x = Math.PI / 2;
                rune.userData = { baseY: 3, offset: Math.random() * Math.PI * 2, type: 'rune' };
                altarGroup.add(rune);
            });
            
            const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1, 0), new THREE.MeshStandardMaterial({ color: 0x7fdb8a, emissive: 0x4f9b5a, transparent: true, opacity: 0.9 }));
            crystal.position.y = 2; crystal.castShadow = true;
            crystal.userData = { rotSpeed: 0.02, baseY: 2, type: 'crystal' };
            altarGroup.add(crystal);
            
            for(let i=0; i<8; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color: 0x7fdb8a, transparent: true, opacity: 0.8}));
                const angle = (i/8)*Math.PI*2;
                p.position.set(Math.cos(angle)*2, 1, Math.sin(angle)*2);
                p.userData = { angle, baseY: 1, speed: 0.03 + Math.random()*0.02, offset: 0, type: 'particle' };
                altarGroup.add(p);
            }
            
            const startY = getTerrainHeight(CONFIG.spawnPoint.x, CONFIG.spawnPoint.z);
            altarGroup.position.set(CONFIG.spawnPoint.x, startY, CONFIG.spawnPoint.z);
            scene.add(altarGroup);
            spawnAltar = altarGroup;

            player.position.y = startY + CONFIG.playerHeight; // Spawn above ground
        }

        // ============ CHUNK SYSTEM ============
        function createChunkObject() {
            const group = new THREE.Group();
            
            const terrain = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize, CONFIG.chunkRes, CONFIG.chunkRes).rotateX(-Math.PI / 2), terrainMat);
            terrain.receiveShadow = true; terrain.frustumCulled = false; 
            group.add(terrain);

            const trunks = new THREE.InstancedMesh(trunkGeo, treeMat, CONFIG.maxTreesPerChunk); trunks.castShadow = true; trunks.receiveShadow = true; trunks.frustumCulled = false;
            const pines = new THREE.InstancedMesh(pineGeo, leavesMat, CONFIG.maxTreesPerChunk); pines.castShadow = true; pines.receiveShadow = true; pines.frustumCulled = false;
            const oaks = new THREE.InstancedMesh(oakGeo, leavesMat, CONFIG.maxTreesPerChunk); oaks.castShadow = true; oaks.receiveShadow = true; oaks.frustumCulled = false;
            const acacias = new THREE.InstancedMesh(acaciaGeo, leavesMat, CONFIG.maxTreesPerChunk); acacias.castShadow = true; acacias.receiveShadow = true; acacias.frustumCulled = false;
            
            group.add(trunks, pines, oaks, acacias);

            const rocks = new THREE.InstancedMesh(rockGeo, rockMat, CONFIG.maxRocksPerChunk); rocks.castShadow = true; rocks.receiveShadow = true; rocks.frustumCulled = false; 
            group.add(rocks);

            const huts = new THREE.InstancedMesh(hutGeo, hutMat, CONFIG.maxHutsPerChunk); huts.castShadow = true; huts.receiveShadow = true; huts.frustumCulled = false;
            group.add(huts);

            return { group, terrain, trunks, pines, oaks, acacias, rocks, huts, colliders: [], active: false };
        }

        function getChunkFromPool() { return chunkPool.length > 0 ? chunkPool.pop() : createChunkObject(); }

        function initChunk(chunk, cx, cz) {
            chunk.group.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize);
            
            const pos = chunk.terrain.geometry.attributes.position;
            const colors = new Float32Array(pos.count * 3);
            const normals = chunk.terrain.geometry.attributes.normal;
            
            const chunkBaseX = cx * CONFIG.chunkSize;
            const chunkBaseZ = cz * CONFIG.chunkSize;

            for(let i=0; i<pos.count; i++) {
                const px = pos.getX(i) + chunkBaseX; const pz = pos.getZ(i) + chunkBaseZ;
                const y = getTerrainHeight(px, pz); pos.setY(i, y);
                const norm = getTerrainNormal(px, pz); normals.setXYZ(i, norm.x, norm.y, norm.z);
                const moisture = mapNoise.fbm(px + 10000, pz + 10000, 3, 0.5, 400);

                const color = new THREE.Color();
                if (norm.y < 0.75 && y > CONFIG.waterLevel + 3) {
                    color.setHex(0x525252).lerp(new THREE.Color(0x404040), mapNoise.noise2D(px, pz)); 
                } else if (y < CONFIG.waterLevel + 1.5) {
                    color.setHex(0x5a5030); 
                } else if (y > 80) {
                    color.setHex(0xeeeeff).lerp(new THREE.Color(0xdddddd), mapNoise.noise2D(px, pz));
                } else if (y < CONFIG.waterLevel + 2 && moisture > 0.5) {
                    color.setHex(0x2d3a1f).lerp(new THREE.Color(0x1a2515), mapNoise.noise2D(px, pz));
                } else if (moisture < 0.35 && y > 30 && y < 70) {
                    color.setHex(0x8faa50).lerp(new THREE.Color(0x7a9a40), mapNoise.noise2D(px, pz));
                } else if (moisture < 0.3 && y > 40 && y < 75) {
                    color.setHex(0x1a2a10).lerp(new THREE.Color(0x0a1505), mapNoise.noise2D(px, pz));
                } else {
                    color.lerpColors(new THREE.Color(0x6b703a), new THREE.Color(0x1b3d16), moisture);
                }
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }
            
            chunk.terrain.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            chunk.terrain.geometry.attributes.position.needsUpdate = true;
            chunk.terrain.geometry.attributes.normal.needsUpdate = true;

            const dummy = new THREE.Object3D(); const leafColor = new THREE.Color();
            let treeIdx = 0, pineIdx = 0, oakIdx = 0, acaciaIdx = 0, rockIdx = 0, hutIdx = 0;
            chunk.colliders.length = 0;

            let rngState = cx * 1000 + cz;
            function rand() { rngState = (rngState * 1664525 + 1013904223) % 4294967296; return rngState / 4294967296; }

            const occupied = []; // Local spatial check to prevent overlaps

            for(let i=0; i < 120; i++) {
                if (treeIdx >= CONFIG.maxTreesPerChunk && rockIdx >= CONFIG.maxRocksPerChunk) break;
                
                const lx = (rand() - 0.5) * CONFIG.chunkSize; const lz = (rand() - 0.5) * CONFIG.chunkSize;
                const wx = lx + chunkBaseX; const wz = lz + chunkBaseZ;
                const wy = getTerrainHeight(wx, wz); const norm = getTerrainNormal(wx, wz);

                if (Math.sqrt((wx - CONFIG.spawnPoint.x)**2 + (wz - CONFIG.spawnPoint.z)**2) < 15) continue;

                const moisture = mapNoise.fbm(wx + 10000, wz + 10000, 3, 0.5, 400);
                
                // Try Rock
                if (wy > CONFIG.waterLevel - 1 && rand() < 0.2 && rockIdx < CONFIG.maxRocksPerChunk) {
                    const s = 0.3 + rand() * 1.8;
                    const r = s * 1.5; // collision radius
                    
                    let canPlace = true;
                    for(let c of occupied) { if(Math.hypot(wx - c.x, wz - c.z) < r + c.r) { canPlace = false; break; } }
                    
                    if (canPlace) {
                        dummy.position.set(lx, wy + s*0.2, lz); dummy.rotation.set(rand()*Math.PI, rand()*Math.PI, rand()*Math.PI); dummy.scale.set(s, s*0.7, s); dummy.updateMatrix();
                        chunk.rocks.setMatrixAt(rockIdx, dummy.matrix);
                        chunk.colliders.push({ x: wx, y: wy, z: wz, radius: r, height: s * 1.4 }); 
                        occupied.push({x: wx, z: wz, r: r});
                        rockIdx++;
                    }
                }

                // Try Tree
                const treeChance = moisture * 0.9; 
                if (wy > CONFIG.waterLevel + 1.5 && wy < 85 && norm.y > 0.85 && rand() < treeChance && treeIdx < CONFIG.maxTreesPerChunk) {
                    const scale = 0.5 + (moisture * 1.5) + (rand() * 0.4); 
                    const r = 0.6 * scale * 2.0; // Avoid rocks
                    
                    // Determine biome for tree type
                    let isPine = false, isOak = false, isAcacia = false, isDeadTree = false;
                    if (wy > 60 || (wy > 40 && moisture < 0.4)) isPine = true;
                    else if (moisture > 0.5 && wy < CONFIG.waterLevel + 5) isOak = true;
                    else if (moisture < 0.35) isAcacia = true;
                    else if (moisture < 0.3) isDeadTree = true;
                    
                    let canPlace = true;
                    for(let c of occupied) { if(Math.hypot(wx - c.x, wz - c.z) < r + c.r) { canPlace = false; break; } }

                    if (canPlace) {
                        dummy.position.set(lx, wy, lz); dummy.rotation.set(0, rand() * Math.PI, 0); dummy.scale.set(scale, scale, scale); dummy.updateMatrix();
                        chunk.trunks.setMatrixAt(treeIdx, dummy.matrix);
                        
                        dummy.position.set(lx, wy, lz); dummy.updateMatrix(); // Leaves offset built into geometry now

                        if (isPine) {
                            chunk.pines.setMatrixAt(pineIdx, dummy.matrix);
                            leafColor.setHex(0x1e3620).lerp(new THREE.Color(0x28472a), rand()); chunk.pines.setColorAt(pineIdx, leafColor); pineIdx++;
                        } else if (isOak) {
                            chunk.oaks.setMatrixAt(oakIdx, dummy.matrix);
                            leafColor.setHex(0x1a401a).lerp(new THREE.Color(0x3a6b22), rand()); chunk.oaks.setColorAt(oakIdx, leafColor); oakIdx++;
                        } else if (isAcacia) {
                            chunk.acacias.setMatrixAt(acaciaIdx, dummy.matrix);
                            leafColor.setHex(0x556b2f).lerp(new THREE.Color(0x6b8e23), rand()); chunk.acacias.setColorAt(acaciaIdx, leafColor); acaciaIdx++;
                        } else if (isDeadTree) {
                            // Dead trees in dark forest - no leaves
                            chunk.deadTrees = chunk.deadTrees || new THREE.InstancedMesh(trunkGeo, trunkMat || new THREE.MeshStandardMaterial({ color: 0x3a3025 }), 50);
                            if (!chunk.deadTrees) { trunkMat = trunkMat || new THREE.MeshStandardMaterial({ color: 0x3a3025, roughness: 1 }); }
                            chunk.deadTrees.setMatrixAt((chunk.deadTrees.count || 0), dummy.matrix);
                            chunk.deadTrees.count = (chunk.deadTrees.count || 0) + 1;
                        } else {
                            chunk.oaks.setMatrixAt(oakIdx, dummy.matrix);
                            leafColor.setHex(0x1a401a).lerp(new THREE.Color(0x3a6b22), rand()); chunk.oaks.setColorAt(oakIdx, leafColor); oakIdx++;
                        }
                        
                        chunk.colliders.push({ x: wx, y: wy, z: wz, radius: 0.6 * scale, height: 10.0 });
                        occupied.push({x: wx, z: wz, r: r});
                        treeIdx++;
                    }
                }
            }

            // Try to spawn huts (very low chance - less common than trees)
            for (let i = 0; i < 30 && hutIdx < CONFIG.maxHutsPerChunk; i++) {
                const lx = (rand() - 0.5) * CONFIG.chunkSize;
                const lz = (rand() - 0.5) * CONFIG.chunkSize;
                const wx = lx + chunkBaseX;
                const wz = lz + chunkBaseZ;
                const wy = getTerrainHeight(wx, wz);

                // Only spawn huts on flat land away from spawn, not in water or mountains
                if (Math.sqrt((wx - CONFIG.spawnPoint.x)**2 + (wz - CONFIG.spawnPoint.z)**2) < 30) continue;
                if (wy < CONFIG.waterLevel + 2 || wy > 60) continue;

                const norm = getTerrainNormal(wx, wz);
                if (norm.y < 0.9) continue; // Must be relatively flat

                // Very low spawn chance (about 3% per attempt)
                if (rand() > 0.03) continue;

                const r = 2.5; // Hut collision radius
                let canPlace = true;
                for (let c of occupied) {
                    if (Math.hypot(wx - c.x, wz - c.z) < r + c.r) {
                        canPlace = false;
                        break;
                    }
                }

                if (canPlace) {
                    const scale = 0.8 + rand() * 0.4;
                    dummy.position.set(lx, wy, lz);
                    dummy.rotation.set(0, rand() * Math.PI * 2, 0);
                    dummy.scale.set(scale, scale, scale);
                    dummy.updateMatrix();
                    chunk.huts.setMatrixAt(hutIdx, dummy.matrix);
                    chunk.colliders.push({ x: wx, y: wy, z: wz, radius: 2.0 * scale, height: 5.0 * scale });
                    occupied.push({ x: wx, z: wz, r: r });
                    hutIdx++;
                }
            }
            
            chunk.trunks.count = treeIdx; chunk.trunks.instanceMatrix.needsUpdate = true;
            chunk.pines.count = pineIdx; chunk.pines.instanceMatrix.needsUpdate = true; if(chunk.pines.instanceColor) chunk.pines.instanceColor.needsUpdate = true;
            chunk.oaks.count = oakIdx; chunk.oaks.instanceMatrix.needsUpdate = true; if(chunk.oaks.instanceColor) chunk.oaks.instanceColor.needsUpdate = true;
            chunk.acacias.count = acaciaIdx; chunk.acacias.instanceMatrix.needsUpdate = true; if(chunk.acacias.instanceColor) chunk.acacias.instanceColor.needsUpdate = true;
            chunk.rocks.count = rockIdx; chunk.rocks.instanceMatrix.needsUpdate = true;
            chunk.huts.count = hutIdx; chunk.huts.instanceMatrix.needsUpdate = true;
            
            chunk.active = true;
        }

        function forceLoadChunks(pcx, pcz) {
            const rd = Math.floor(CONFIG.renderDist/2);
            let loaded = 0, total = (rd*2+1)**2;
            for(let dx = -rd; dx <= rd; dx++) {
                for(let dz = -rd; dz <= rd; dz++) {
                    const key = `${pcx+dx},${pcz+dz}`;
                    const chunk = getChunkFromPool(); initChunk(chunk, pcx+dx, pcz+dz);
                    activeChunks.set(key, chunk); scene.add(chunk.group);
                    loaded++; updateLoading((loaded/total)*100);
                }
            }
        }

        function updateChunks() {
            const pcx = Math.floor(player.position.x / CONFIG.chunkSize); const pcz = Math.floor(player.position.z / CONFIG.chunkSize);
            const keepKeys = new Set();
            for(let dx = -CONFIG.renderDist; dx <= CONFIG.renderDist; dx++) {
                for(let dz = -CONFIG.renderDist; dz <= CONFIG.renderDist; dz++) {
                    if (dx*dx + dz*dz <= CONFIG.renderDist*CONFIG.renderDist) {
                        const key = `${pcx+dx},${pcz+dz}`; keepKeys.add(key);
                        if (!activeChunks.has(key) && !chunkQueue.some(c => c.key === key)) chunkQueue.push({ key, cx: pcx+dx, cz: pcz+dz, distSq: dx*dx+dz*dz });
                    }
                }
            }
            for(const [key, chunk] of activeChunks.entries()) {
                if (!keepKeys.has(key)) { scene.remove(chunk.group); chunk.active = false; chunkPool.push(chunk); activeChunks.delete(key); }
            }
            if (chunkQueue.length > 0) {
                chunkQueue.sort((a,b) => a.distSq - b.distSq);
                const item = chunkQueue.shift();
                if (keepKeys.has(item.key)) {
                    const chunk = getChunkFromPool(); initChunk(chunk, item.cx, item.cz);
                    activeChunks.set(item.key, chunk); scene.add(chunk.group);
                }
            }
        }

        function createInfiniteWater() {
            water = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000, 32, 32).rotateX(-Math.PI / 2), new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uColor1: { value: new THREE.Color(0x0077be) }, uColor2: { value: new THREE.Color(0x00aadd) } },
                vertexShader: `uniform float uTime; varying float vElevation; void main() { vec4 worldPos = modelMatrix * vec4(position, 1.0); worldPos.y += sin(worldPos.x * 0.2 + uTime) * 0.2 + sin(worldPos.z * 0.2 + uTime * 0.8) * 0.2; vElevation = worldPos.y; gl_Position = projectionMatrix * viewMatrix * worldPos; }`,
                fragmentShader: `uniform vec3 uColor1, uColor2; varying float vElevation; void main() { gl_FragColor = vec4(mix(uColor1, uColor2, (vElevation - 3.5) * 1.5), 0.85); }`,
                transparent: true, side: THREE.DoubleSide
            }));
            scene.add(water);
        }

        function createInfiniteSkybox() {
            skybox = new THREE.Mesh(new THREE.SphereGeometry(800, 32, 32), new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uDayColor: { value: new THREE.Color(0x7ec0ee) },
                    uNightColor: { value: new THREE.Color(0x02040a) },
                    uSunPosition: { value: new THREE.Vector3(0, 1, 0) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPos.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uDayColor;
                    uniform vec3 uNightColor;
                    uniform vec3 uSunPosition;
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    }
                    
                    float fbm(vec2 p) {
                        float v = 0.0;
                        float a = 0.5;
                        for (int i = 0; i < 5; i++) {
                            v += a * noise(p);
                            p *= 2.0;
                            a *= 0.5;
                        }
                        return v;
                    }
                    
                    void main() {
                        vec3 dir = normalize(vWorldPosition);
                        float y = dir.y * 0.5 + 0.5;
                        
                        // Day/night blend based on sun height
                        float sunHeight = uSunPosition.y;
                        float dayFactor = smoothstep(-0.1, 0.3, sunHeight);
                        float nightFactor = 1.0 - dayFactor;
                        
                        // Base sky color
                        vec3 skyColor = mix(uNightColor, uDayColor, dayFactor);
                        
                        // Clouds
                        vec2 cloudUv = dir.xz / (dir.y + 0.3) * 2.0;
                        cloudUv += uTime * 0.02;
                        float clouds = fbm(cloudUv * 3.0);
                        clouds = smoothstep(0.4, 0.7, clouds);
                        vec3 cloudColor = mix(vec3(0.9, 0.95, 1.0), vec3(1.0, 0.9, 0.8), 1.0 - dayFactor);
                        skyColor = mix(skyColor, cloudColor, clouds * dayFactor * 0.7);
                        
                        // Stars at night
                        if (nightFactor > 0.1) {
                            vec2 starUv = dir.xz * 100.0;
                            float stars = step(0.998, hash(floor(starUv)));
                            float twinkle = sin(uTime * 3.0 + hash(floor(starUv)) * 100.0) * 0.5 + 0.5;
                            skyColor += vec3(stars * twinkle * nightFactor);
                            
                            // Shooting stars occasionally
                            float shootingStar = step(0.9999, hash(vec2(floor(uTime * 10.0), 1.0)));
                            if (shootingStar > 0.5) {
                                vec2 shootUv = fract(dir.xz * 50.0 + vec2(uTime * 2.0, 0.0));
                                float shoot = smoothstep(0.02, 0.0, abs(shootUv.x - shootUv.y));
                                skyColor += vec3(shoot * nightFactor * 2.0);
                            }
                        }
                        
                        // Twilight colors
                        float twilightFactor = 1.0 - abs(sunHeight);
                        if (sunHeight < 0.2 && sunHeight > -0.1) {
                            vec3 twilightColor = mix(vec3(1.0, 0.4, 0.2), vec3(0.3, 0.1, 0.3), (sunHeight + 0.1) / 0.3);
                            skyColor = mix(skyColor, twilightColor, twilightFactor * 0.6);
                        }
                        
                        gl_FragColor = vec4(skyColor, 1.0);
                    }
                `,
                side: THREE.BackSide, fog: false
            }));
            scene.add(skybox);
        }

        function createFireflies() {
            const count = 1000; const pos = new Float32Array(count * 3); const phases = new Float32Array(count);
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random() - 0.5) * 200; pos[i*3+1] = Math.random() * 15; pos[i*3+2] = (Math.random() - 0.5) * 200;
                phases[i] = Math.random() * Math.PI * 2;
            }
            const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geo.setAttribute('aPhase', new THREE.BufferAttribute(phases, 1));
            fireflies = new THREE.Points(geo, new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uNightFactor: { value: 0.0 } },
                vertexShader: `uniform float uTime; attribute float aPhase; varying float vAlpha; void main() { vec3 p = position; p.y += sin(uTime * 0.5 + aPhase) * 0.5; p.x += cos(uTime * 0.3 + aPhase) * 0.5; vec4 mvPosition = modelViewMatrix * vec4(p, 1.0); gl_PointSize = (10.0 / -mvPosition.z); vAlpha = 0.5 + sin(uTime * 2.0 + aPhase) * 0.5; gl_Position = projectionMatrix * mvPosition; }`,
                fragmentShader: `uniform float uNightFactor; varying float vAlpha; void main() { float dist = length(gl_PointCoord - vec2(0.5)); if(dist > 0.5) discard; gl_FragColor = vec4(0.5, 1.0, 0.5, vAlpha * (1.0 - dist*2.0) * uNightFactor); }`,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            }));
            scene.add(fireflies);
        }

        // ============ WEATHER SYSTEM ============
        let rain, mist, lightning;
        let weatherState = { isRaining: false, isStorming: false, mistDensity: 0, rainIntensity: 0 };
        
        function createWeatherSystem() {
            // Rain particles
            const rainCount = 5000;
            const rainGeo = new THREE.BufferGeometry();
            const rainPositions = new Float32Array(rainCount * 3);
            for (let i = 0; i < rainCount; i++) {
                rainPositions[i * 3] = (Math.random() - 0.5) * 100;
                rainPositions[i * 3 + 1] = Math.random() * 50;
                rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
            rain = new THREE.Points(rainGeo, new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uIntensity: { value: 0 } },
                vertexShader: `uniform float uTime; uniform float uIntensity; void main() {
                    vec3 pos = position;
                    pos.y = mod(pos.y - uTime * 30.0, 50.0);
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = (3.0 * uIntensity) / -mvPosition.z;
                    gl_Position = projectionMatrix * mvPosition;
                }`,
                fragmentShader: `uniform float uIntensity; void main() {
                    gl_FragColor = vec4(0.7, 0.8, 1.0, uIntensity * 0.6);
                }`,
                transparent: true, depthWrite: false
            }));
            rain.visible = false;
            scene.add(rain);
            scene.userData.weather = rain;

            // Ground mist
            mist = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200, 1, 1),
                new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 }, uDensity: { value: 0 } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `uniform float uTime; uniform float uDensity; varying vec2 vUv;
                        float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
                        void main() {
                            float n = noise(vUv * 10.0 + uTime * 0.1);
                            float alpha = uDensity * 0.4 * n * (1.0 - length(vUv - 0.5) * 1.5);
                            gl_FragColor = vec4(0.9, 0.95, 1.0, alpha);
                        }`,
                    transparent: true, depthWrite: false, side: THREE.DoubleSide
                })
            );
            mist.rotation.x = -Math.PI / 2;
            mist.position.y = CONFIG.waterLevel + 2;
            mist.visible = false;
            scene.add(mist);

            // Lightning light
            lightning = new THREE.DirectionalLight(0xffffff, 0);
            lightning.position.set(0, 100, 0);
            scene.add(lightning);
            scene.userData.lightning = lightning;
        }

        // ============ SOUND SYSTEM ============
        let windSound, cricketsSound;
        let audioInitialized = false;
        
        function initAudio() {
            if (audioInitialized) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
                
                // Wind sound (filtered noise)
                const windNoise = audioContext.createBufferSource();
                const bufferSize = audioContext.sampleRate * 2;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                windNoise.buffer = noiseBuffer;
                windNoise.loop = true;
                const windFilter = audioContext.createBiquadFilter();
                windFilter.type = 'lowpass';
                windFilter.frequency.value = 400;
                const windGain = audioContext.createGain();
                windGain.gain.value = 0.15;
                windNoise.connect(windFilter);
                windFilter.connect(windGain);
                windGain.connect(masterGain);
                windNoise.start();
                
                // Crickets (oscillator with modulation)
                const cricketOsc = audioContext.createOscillator();
                cricketOsc.type = 'sine';
                cricketOsc.frequency.value = 4000;
                const cricketGain = audioContext.createGain();
                cricketGain.gain.value = 0;
                const cricketLfo = audioContext.createOscillator();
                cricketLfo.frequency.value = 15;
                const cricketLfoGain = audioContext.createGain();
                cricketLfoGain.gain.value = 500;
                cricketLfo.connect(cricketLfoGain);
                cricketLfoGain.connect(cricketOsc.frequency);
                cricketOsc.connect(cricketGain);
                cricketGain.connect(masterGain);
                cricketOsc.start();
                cricketLfo.start();
                
                windSound = windGain;
                cricketsSound = cricketGain;
                
                audioInitialized = true;
                scene.userData.audioInitialized = true;
            } catch (e) {
                console.log('Audio not available');
            }
        }
        
        function updateAudio(sunFactor) {
            if (!audioInitialized) return;
            const nightFactor = 1 - sunFactor;
            cricketsSound.gain.setTargetAtTime(nightFactor * 0.08, audioContext.currentTime, 0.5);
            windSound.gain.setTargetAtTime(0.1 + nightFactor * 0.1, audioContext.currentTime, 0.5);
        }
        
        function playBirdChirp() {
            if (!audioInitialized || Math.random() > 0.015) return;
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 2000 + Math.random() * 2000;
            const gain = audioContext.createGain();
            gain.gain.value = 0.03;
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioContext.currentTime + 0.2);
        }

        // ============ BUTTERFLIES & POLLEN ============
        let butterflies, pollen;
        
        function createButterfliesAndPollen() {
            // Butterflies
            const butterflyCount = 100;
            const butterflyGeo = new THREE.BufferGeometry();
            const butterflyPos = new Float32Array(butterflyCount * 3);
            const butterflyPhases = new Float32Array(butterflyCount);
            for (let i = 0; i < butterflyCount; i++) {
                butterflyPos[i * 3] = (Math.random() - 0.5) * 60;
                butterflyPos[i * 3 + 1] = 2 + Math.random() * 8;
                butterflyPos[i * 3 + 2] = (Math.random() - 0.5) * 60;
                butterflyPhases[i] = Math.random() * Math.PI * 2;
            }
            butterflyGeo.setAttribute('position', new THREE.BufferAttribute(butterflyPos, 3));
            butterflyGeo.setAttribute('aPhase', new THREE.BufferAttribute(butterflyPhases, 1));
            
            butterflies = new THREE.Points(butterflyGeo, new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uDayFactor: { value: 1.0 } },
                vertexShader: `
                    uniform float uTime;
                    attribute float aPhase;
                    varying float vAlpha;
                    void main() {
                        vec3 p = position;
                        p.y += sin(uTime * 2.0 + aPhase) * 1.5;
                        p.x += sin(uTime * 1.5 + aPhase) * 3.0;
                        p.z += cos(uTime * 1.2 + aPhase) * 3.0;
                        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                        gl_PointSize = (8.0 / -mvPosition.z);
                        vAlpha = 0.7 + sin(uTime * 5.0 + aPhase) * 0.3;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float uDayFactor;
                    varying float vAlpha;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        vec3 color = mix(vec3(1.0, 0.8, 0.2), vec3(0.8, 0.4, 1.0), fract(gl_PointCoord.x * 2.0));
                        gl_FragColor = vec4(color, vAlpha * uDayFactor);
                    }
                `,
                transparent: true, depthWrite: false
            }));
            scene.add(butterflies);
            
            // Pollen particles (sunlight particles)
            const pollenCount = 500;
            const pollenGeo = new THREE.BufferGeometry();
            const pollenPos = new Float32Array(pollenCount * 3);
            const pollenPhases = new Float32Array(pollenCount);
            for (let i = 0; i < pollenCount; i++) {
                pollenPos[i * 3] = (Math.random() - 0.5) * 40;
                pollenPos[i * 3 + 1] = Math.random() * 12;
                pollenPos[i * 3 + 2] = (Math.random() - 0.5) * 40;
                pollenPhases[i] = Math.random() * Math.PI * 2;
            }
            pollenGeo.setAttribute('position', new THREE.BufferAttribute(pollenPos, 3));
            pollenGeo.setAttribute('aPhase', new THREE.BufferAttribute(pollenPhases, 1));
            
            pollen = new THREE.Points(pollenGeo, new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uDayFactor: { value: 1.0 } },
                vertexShader: `
                    uniform float uTime;
                    attribute float aPhase;
                    varying float vAlpha;
                    void main() {
                        vec3 p = position;
                        p.y += sin(uTime * 0.5 + aPhase) * 0.5;
                        p.x += cos(uTime * 0.3 + aPhase) * 0.3;
                        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                        gl_PointSize = (4.0 / -mvPosition.z);
                        vAlpha = 0.3 + sin(uTime * 2.0 + aPhase) * 0.2;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float uDayFactor;
                    varying float vAlpha;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        gl_FragColor = vec4(1.0, 1.0, 0.8, vAlpha * uDayFactor * 0.5);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            }));
            scene.add(pollen);
        }

        function updateButterfliesAndPollen(time, sunFactor) {
            if (butterflies) {
                butterflies.position.copy(player.position);
                butterflies.material.uniforms.uTime.value = time;
                butterflies.material.uniforms.uDayFactor.value = sunFactor;
                butterflies.visible = sunFactor > 0.3;
            }
            if (pollen) {
                pollen.position.copy(player.position);
                pollen.material.uniforms.uTime.value = time;
                pollen.material.uniforms.uDayFactor.value = sunFactor;
                pollen.visible = sunFactor > 0.2;
            }
        }

        // ============ WORLD LANDMARKS ============
        function createLandmarks() {
            const landmarkPositions = [
                { x: 80, z: 80, type: 'giantTree' },
                { x: -120, z: 60, type: 'stoneCircle' },
                { x: 150, z: -80, type: 'ruinedTower' },
                { x: -60, z: -150, type: 'campsite' }
            ];
            
            for (const lm of landmarkPositions) {
                const y = getTerrainHeight(lm.x, lm.z);
                
                if (lm.type === 'giantTree') {
                    // Giant ancient tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 4, 25, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 1 })
                    );
                    trunk.position.set(lm.x, y + 12, lm.z);
                    scene.add(trunk);
                    
                    // Add multiple leaf clusters
                    for (let i = 0; i < 5; i++) {
                        const leaves = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(8 - i),
                            new THREE.MeshStandardMaterial({ color: 0x1a3a1a, flatShading: true })
                        );
                        leaves.position.set(
                            lm.x + (Math.random() - 0.5) * 10,
                            y + 20 + i * 4,
                            lm.z + (Math.random() - 0.5) * 10
                        );
                        scene.add(leaves);
                    }
                }
                else if (lm.type === 'stoneCircle') {
                    // Stone circle landmark
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const stone = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 4, 1.5),
                            new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 })
                        );
                        stone.position.set(
                            lm.x + Math.cos(angle) * 12,
                            y + 2,
                            lm.z + Math.sin(angle) * 12
                        );
                        stone.rotation.y = angle;
                        stone.rotation.x = (Math.random() - 0.5) * 0.3;
                        scene.add(stone);
                    }
                    // Center altar stone
                    const centerStone = new THREE.Mesh(
                        new THREE.CylinderGeometry(3, 4, 2, 6),
                        new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 })
                    );
                    centerStone.position.set(lm.x, y + 1, lm.z);
                    scene.add(centerStone);
                }
                else if (lm.type === 'ruinedTower') {
                    // Ruined tower
                    for (let i = 0; i < 4; i++) {
                        const wall = new THREE.Mesh(
                            new THREE.BoxGeometry(8, 15, 1),
                            new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 })
                        );
                        wall.position.set(lm.x, y + 7, lm.z);
                        wall.rotation.y = (i / 4) * Math.PI * 2;
                        wall.position.x += Math.cos(wall.rotation.y) * 5;
                        wall.position.z += Math.sin(wall.rotation.y) * 5;
                        scene.add(wall);
                    }
                }
                else if (lm.type === 'campsite') {
                    // Abandoned campsite with fire
                    const fireLight = new THREE.PointLight(0xff6600, 2, 20);
                    fireLight.position.set(lm.x, y + 1, lm.z);
                    scene.add(fireLight);
                    
                    // Logs around fire
                    for (let i = 0; i < 5; i++) {
                        const log = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 6),
                            new THREE.MeshStandardMaterial({ color: 0x3a2010 })
                        );
                        log.position.set(
                            lm.x + (Math.random() - 0.5) * 3,
                            y + 0.3,
                            lm.z + (Math.random() - 0.5) * 3
                        );
                        log.rotation.z = Math.PI / 2;
                        log.rotation.y = Math.random() * Math.PI;
                        scene.add(log);
                    }
                    scene.userData.fireLight = fireLight;
                }
            }
        }

        function updateWeather(time, dt) {
            if (!scene.userData.weather) return;
            
            // Random weather changes
            const weatherCycle = Math.sin(time * 0.01) * 0.5 + 0.5;
            const isStorming = weatherCycle > 0.7;
            const isRaining = weatherCycle > 0.4;
            
            // Rain
            rain.visible = isRaining;
            rain.material.uniforms.uTime.value = time;
            rain.material.uniforms.uIntensity.value = isStorming ? 1.0 : 0.5;
            rain.position.copy(player.position);
            rain.position.y = player.position.y + 20;

            // Mist in valleys
            const inValley = player.position.y < CONFIG.waterLevel + 5;
            const mistDensity = inValley ? 0.6 : (isRaining ? 0.3 : 0.1);
            mist.visible = mistDensity > 0.05;
            mist.material.uniforms.uDensity.value = mistDensity;
            mist.material.uniforms.uTime.value = time;
            mist.position.x = player.position.x;
            mist.position.z = player.position.z;

            // Lightning during storms
            if (isStorming && Math.random() < 0.002) {
                lightning.intensity = 3.0;
                setTimeout(() => { lightning.intensity = 0; }, 100);
            }
        }

        function updateEnvironment(time) {
            water.material.uniforms.uTime.value = time; water.position.set(player.position.x, CONFIG.waterLevel, player.position.z);
            skybox.position.copy(player.position);
            
            const offsetTime = time + (CONFIG.cycleDuration * 0.25);
            const cycleProgress = (offsetTime % CONFIG.cycleDuration) / CONFIG.cycleDuration; 
            const theta = cycleProgress * Math.PI * 2; 

            const sunY = Math.sin(theta); const sunX = Math.cos(theta);
            const sun = scene.userData.sun; const moon = scene.userData.moon; const hemi = scene.userData.hemi;
            const sunMesh = scene.userData.sunMesh; const moonMesh = scene.userData.moonMesh;

            if(sun && moon && hemi) {
                const orbitRadius = 400;
                sun.position.set(player.position.x + sunX * orbitRadius, sunY * orbitRadius, player.position.z + 100);
                moon.position.set(player.position.x - sunX * orbitRadius, -sunY * orbitRadius, player.position.z - 100);
                
                // Update visible sun and moon mesh positions
                if (sunMesh) sunMesh.position.copy(sun.position);
                if (moonMesh) moonMesh.position.copy(moon.position);
                
                sun.target.position.copy(player.position); sun.target.updateMatrixWorld();
                moon.target.position.copy(player.position); moon.target.updateMatrixWorld();

                const sunFactor = Math.max(0, sunY); const moonFactor = Math.max(0, -sunY);
                scene.userData.sunFactor = sunFactor;
                sun.intensity = sunFactor * 1.5; moon.intensity = moonFactor * 0.5;

                // Show/hide sun and moon meshes based on time of day
                if (sunMesh) {
                    sunMesh.visible = sunFactor > 0.05;
                }
                if (moonMesh) {
                    moonMesh.visible = moonFactor > 0.05;
                }

                const daySky = new THREE.Color(0x7ec0ee); const nightSky = new THREE.Color(0x02040a);
                const twilightBlend = Math.max(0, Math.min(1, sunY + 0.2)); 
                const currentSky = new THREE.Color().lerpColors(nightSky, daySky, twilightBlend);

                scene.background.copy(currentSky); scene.fog.color.copy(currentSky);
                skybox.material.uniforms.uTime.value = time;
                skybox.material.uniforms.uSunPosition.value.set(sunX, sunY, 0);
                hemi.color.lerpColors(new THREE.Color(0x051020), daySky, sunFactor);
                hemi.groundColor.lerpColors(new THREE.Color(0x020502), new THREE.Color(0x1a2a1a), sunFactor);

                // Update butterflies and pollen
                updateButterfliesAndPollen(time, sunFactor);

                if (fireflies) fireflies.material.uniforms.uNightFactor.value = Math.pow(moonFactor, 0.5);
            }

            if (fireflies) {
                fireflies.material.uniforms.uTime.value = time;
                const pos = fireflies.geometry.attributes.position;
                for(let i=0; i<pos.count; i++) {
                    const idx = i*3; let dx = pos.array[idx] - player.position.x; let dz = pos.array[idx+2] - player.position.z;
                    if (dx > 100) pos.array[idx] -= 200; if (dx < -100) pos.array[idx] += 200;
                    if (dz > 100) pos.array[idx+2] -= 200; if (dz < -100) pos.array[idx+2] += 200;
                    pos.array[idx+1] = THREE.MathUtils.lerp(pos.array[idx+1], getTerrainHeight(pos.array[idx], pos.array[idx+2]) + 1.5, 0.1);
                }
                pos.needsUpdate = true;
            }
        }

        function updateAltar(time) {
            if (!spawnAltar) return;
            spawnAltar.children.forEach(c => {
                if (c.userData && c.userData.type) {
                    if (c.userData.type === 'rune') { c.rotation.z += 0.02; c.position.y = c.userData.baseY + Math.sin(time*2 + c.userData.offset)*0.15; }
                    else if (c.userData.type === 'crystal') { c.rotation.y += c.userData.rotSpeed; c.rotation.x += c.userData.rotSpeed * 0.5; c.position.y = c.userData.baseY + Math.sin(time*1.5)*0.2; }
                    else if (c.userData.type === 'particle') { c.userData.offset += c.userData.speed; c.position.y = c.userData.baseY + Math.sin(c.userData.offset)*0.3; c.position.x = Math.cos(c.userData.angle + time*0.5)*2.5; c.position.z = Math.sin(c.userData.angle + time*0.5)*2.5; }
                }
            });
        }

        // ============ CUSTOM ANIMALS ============
        function createAnimal(type) {
            const group = new THREE.Group();
            
            if (type === 'bear') {
                const mat = new THREE.MeshStandardMaterial({ color: 0x221100, roughness: 0.9 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.7, 1.3), mat); body.position.y = 0.6; group.add(body);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat); head.position.set(0, 0.8, 0.7); group.add(head);
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshStandardMaterial({color: 0x442200})); snout.position.set(0, 0.75, 0.9); group.add(snout);
                const earL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), mat); earL.position.set(-0.15, 1.05, 0.6); group.add(earL);
                const earR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), mat); earR.position.set(0.15, 1.05, 0.6); group.add(earR);
                const legs = [];
                [[-0.3, 0.25, -0.4], [0.3, 0.25, -0.4], [-0.3, 0.25, 0.4], [0.3, 0.25, 0.4]].forEach(pos => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), mat); leg.position.set(...pos); group.add(leg); legs.push(leg);
                });
                group.children.forEach(c => c.castShadow = true);
                return { mesh: group, legs, speed: 1.5 };
                
            } else if (type === 'deer') {
                const mat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.8 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.0), mat); body.position.y = 0.8; group.add(body);
                const neck = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), mat); neck.position.set(0, 1.1, 0.4); neck.rotation.x = 0.2; group.add(neck);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.4), mat); head.position.set(0, 1.3, 0.5); group.add(head);
                
                const hornMat = new THREE.MeshStandardMaterial({color: 0xddccaa});
                const hornL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.05), hornMat); hornL.position.set(-0.1, 1.5, 0.4); hornL.rotation.z = 0.2; group.add(hornL);
                const hornR = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.05), hornMat); hornR.position.set(0.1, 1.5, 0.4); hornR.rotation.z = -0.2; group.add(hornR);
                
                const legs = [];
                [[-0.15, 0.4, -0.4], [0.15, 0.4, -0.4], [-0.15, 0.4, 0.3], [0.15, 0.4, 0.3]].forEach(pos => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.08), mat); leg.position.set(...pos); group.add(leg); legs.push(leg);
                });
                group.children.forEach(c => c.castShadow = true);
                return { mesh: group, legs, speed: 3.5 };
                
            } else if (type === 'fox') {
                const mat = new THREE.MeshStandardMaterial({ color: 0xd95a00, roughness: 0.7 });
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.7 });
                
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.7), mat); body.position.y = 0.4; group.add(body);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), mat); head.position.set(0, 0.6, 0.4); group.add(head);
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.2), whiteMat); snout.position.set(0, 0.55, 0.55); group.add(snout);
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.5), mat); tail.position.set(0, 0.4, -0.5); tail.rotation.x = -0.2; group.add(tail);
                const earL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.05), mat); earL.position.set(-0.1, 0.75, 0.35); group.add(earL);
                const earR = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.05), mat); earR.position.set(0.1, 0.75, 0.35); group.add(earR);
                
                const legs = [];
                [[-0.1, 0.15, -0.2], [0.1, 0.15, -0.2], [-0.1, 0.15, 0.2], [0.1, 0.15, 0.2]].forEach(pos => {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), mat); leg.position.set(...pos); group.add(leg); legs.push(leg);
                });
                group.children.forEach(c => c.castShadow = true);
                return { mesh: group, legs, speed: 4.0 };
            }
        }

        function createMobs() {
            const types = ['bear', 'deer', 'fox'];
            for (let i = 0; i < 20; i++) {
                const animal = createAnimal(types[i % 3]);
                // Spawn on land only, not in water or mountains
                let validPos = false;
                let attempts = 0;
                let mx, mz, my;
                while (!validPos && attempts < 50) {
                    mx = (Math.random() - 0.5) * 150;
                    mz = (Math.random() - 0.5) * 150;
                    my = getTerrainHeight(mx, mz);
                    // Only spawn on land above water and below high mountains
                    if (my > CONFIG.waterLevel + 1 && my < 70) {
                        validPos = true;
                    }
                    attempts++;
                }
                // Fallback if no valid position found
                if (!validPos) {
                    mx = (Math.random() - 0.5) * 150;
                    mz = (Math.random() - 0.5) * 150;
                    my = getTerrainHeight(mx, mz);
                }
                animal.mesh.position.set(mx, my + 0.1, mz); 
                scene.add(animal.mesh);
                mobs.push({ mesh: animal.mesh, legs: animal.legs, targetAngle: Math.random() * Math.PI * 2, stateTimer: 0, speed: animal.speed, walkCycle: 0 });
            }
        }

        // ============ PLAYER WITH ASSEMBLY ============
        function createPlayerModel() {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.6 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xfcd34d, roughness: 0.5 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.8 });

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 0.4), mat); torso.position.y = 1.1; group.add(torso);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMat); head.position.y = 1.85; group.add(head);
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), skinMat); leftArm.position.set(-0.5, 1.1, 0); group.add(leftArm);
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), skinMat); rightArm.position.set(0.5, 1.1, 0); group.add(rightArm);
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), darkMat); leftLeg.position.set(-0.2, 0.45, 0); group.add(leftLeg);
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), darkMat); rightLeg.position.set(0.2, 0.45, 0); group.add(rightLeg);
            
            group.children.forEach(c => {
                c.castShadow = true;
                c.userData.targetPos = c.position.clone();
                // Start parts high in space with random positions
                const startY = 80 + Math.random() * 40;
                const startX = (Math.random() - 0.5) * 60;
                const startZ = (Math.random() - 0.5) * 60;
                c.userData.startPos = new THREE.Vector3(startX, startY, startZ);
                c.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    -15 - Math.random() * 10,
                    (Math.random() - 0.5) * 2
                );
                c.userData.isFalling = true;
                c.userData.hasLanded = false;
                c.userData.landedPos = c.position.clone();
                c.position.copy(c.userData.startPos);
            }); 
            
            scene.add(group); 
            return { group, parts: { torso, head, leftArm, rightArm, leftLeg, rightLeg } };
        }

        // ============ CONTROLS & PHYSICS ============
        function setupEvents() {
            document.addEventListener('keydown', (e) => { keys[e.code] = true; if (e.code === 'KeyC' && !player.isSpawning) toggleCamera(); if (e.code === 'KeyV' && !player.isSpawning) toggleCinematicMode(); });
            document.addEventListener('keyup', (e) => { keys[e.code] = false; });
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;
                player.yaw -= e.movementX * 0.0025;
                player.pitch = THREE.MathUtils.clamp(player.pitch - e.movementY * 0.0025, -Math.PI/2 + 0.1, Math.PI/2 - 0.1);
            });
            document.getElementById('click-to-start').addEventListener('click', () => { renderer.domElement.requestPointerLock(); });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                document.getElementById('click-to-start').classList.toggle('hidden', isPointerLocked);
                
                if (isPointerLocked && player.isSpawning) {
                    const eff = document.getElementById('spawn-effect');
                    eff.classList.remove('active'); void eff.offsetWidth; eff.classList.add('active');
                    document.body.classList.add('spawning');
                } else if (isPointerLocked && !player.isSpawning && isFirstPerson) {
                    document.getElementById('crosshair').classList.add('visible');
                } else {
                    document.getElementById('crosshair').classList.remove('visible');
                }
            });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            
            // Mobile controls
            const mobileBtns = {
                'btn-w': 'KeyW',
                'btn-a': 'KeyA',
                'btn-s': 'KeyS',
                'btn-d': 'KeyD',
                'btn-space': 'Space',
                'btn-shift': 'ShiftLeft'
            };
            
            for (const [btnId, keyCode] of Object.entries(mobileBtns)) {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyCode] = true; });
                    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyCode] = false; });
                    btn.addEventListener('mousedown', (e) => { e.preventDefault(); keys[keyCode] = true; });
                    btn.addEventListener('mouseup', (e) => { e.preventDefault(); keys[keyCode] = false; });
                }
            }
            
            // Touch look controls
            let touchStartX = 0, touchStartY = 0;
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    // Start spawn if not spawning
                    if (player.isSpawning && !document.body.classList.contains('spawning')) {
                        const eff = document.getElementById('spawn-effect');
                        eff.classList.remove('active'); void eff.offsetWidth; eff.classList.add('active');
                        document.body.classList.add('spawning');
                    }
                }
            });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && !player.isSpawning) {
                    const dx = e.touches[0].clientX - touchStartX;
                    const dy = e.touches[0].clientY - touchStartY;
                    player.yaw -= dx * 0.005;
                    player.pitch = THREE.MathUtils.clamp(player.pitch - dy * 0.005, -Math.PI/2 + 0.1, Math.PI/2 - 0.1);
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
            
            // Show mobile controls hint on mobile
            if (window.matchMedia('(pointer: coarse)').matches) {
                document.getElementById('click-to-start').querySelector('p').textContent = 'Tap to start - Touch controls at bottom';
            }
        }

        function toggleCamera() {
            isFirstPerson = !isFirstPerson;
            document.getElementById('mode').textContent = isFirstPerson ? 'First Person' : 'Third Person';
            document.getElementById('crosshair').classList.toggle('visible', isFirstPerson && isPointerLocked);
            playerModelData.group.visible = !isFirstPerson;
        }

        // Cinematic mode variables
        let isCinematicMode = false;
        let cinematicOrbitAngle = 0;
        let cinematicHeight = 30;
        let cinematicDistance = 50;
        
        function toggleCinematicMode() {
            isCinematicMode = !isCinematicMode;
            document.getElementById('mode').textContent = isCinematicMode ? 'Cinematic' : (isFirstPerson ? 'First Person' : 'Third Person');
            document.getElementById('crosshair').classList.toggle('visible', isFirstPerson && isPointerLocked);
            playerModelData.group.visible = true;
        }
        
        function updateCinematicCamera(time, delta) {
            if (!isCinematicMode) return;
            
            // Slow orbit around player
            cinematicOrbitAngle += delta * 0.2;
            
            // Sine wave height
            cinematicHeight = 20 + Math.sin(time * 0.3) * 15;
            
            const targetX = player.position.x + Math.sin(cinematicOrbitAngle) * cinematicDistance;
            const targetZ = player.position.z + Math.cos(cinematicOrbitAngle) * cinematicDistance;
            const targetY = player.position.y + cinematicHeight;
            
            camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.02);
            camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
        }

        function getActiveColliders(px, pz) {
            const pcx = Math.floor(px / CONFIG.chunkSize); const pcz = Math.floor(pz / CONFIG.chunkSize);
            activeColliders.length = 0;
            for(let dx=-1; dx<=1; dx++) {
                for(let dz=-1; dz<=1; dz++) {
                    const chunk = activeChunks.get(`${pcx+dx},${pcz+dz}`);
                    if (chunk && chunk.active) { for(let i=0; i<chunk.colliders.length; i++) activeColliders.push(chunk.colliders[i]); }
                }
            }
        }

        function checkCollision(nx, ny, nz) {
            for (let c of activeColliders) {
                if (Math.abs(nx - c.x) > 2 || Math.abs(nz - c.z) > 2) continue;
                // Allow jumping ON rocks (if player feet > rock top)
                if (ny >= c.y + c.height) continue; 
                if ((nx - c.x)**2 + (nz - c.z)**2 < (c.radius + CONFIG.playerRadius)**2) return true;
            }
            return false;
        }

        function updatePlayer(delta, time) {
            if (player.isSpawning) {
                player.spawnTimer += delta;
                const totalSpawnTime = 4.0;
                const progress = Math.min(player.spawnTimer / totalSpawnTime, 1.0);
                
                const targetY = getTerrainHeight(CONFIG.spawnPoint.x, CONFIG.spawnPoint.z) + CONFIG.playerHeight;
                player.position.y = THREE.MathUtils.lerp(player.position.y, targetY, 0.03);
                
                const pm = playerModelData;
                pm.group.position.copy(player.position); 
                pm.group.position.y -= CONFIG.playerHeight * 0.9; 
                pm.group.rotation.y = time; 

                // Update falling parts physics
                let allLanded = true;
                for(let key in pm.parts) {
                    let p = pm.parts[key];
                    
                    if (p.userData.isFalling) {
                        allLanded = false;
                        // Apply gravity
                        p.userData.velocity.y += CONFIG.gravity * delta * 0.5;
                        
                        // Update position
                        p.position.x += p.userData.velocity.x * delta;
                        p.position.y += p.userData.velocity.y * delta;
                        p.position.z += p.userData.velocity.z * delta;
                        
                        // Add rotation while falling
                        p.rotation.x += delta * 2;
                        p.rotation.z += delta * 1.5;
                        
                        // Check if hit ground
                        const groundY = getTerrainHeight(player.position.x, player.position.z);
                        if (p.position.y <= groundY + p.userData.targetPos.y) {
                            p.position.y = groundY + p.userData.targetPos.y;
                            p.userData.isFalling = false;
                            p.userData.hasLanded = true;
                            p.userData.landedPos = p.position.clone();
                            // Stop rotation
                            p.rotation.set(0, 0, 0);
                        }
                    } else {
                        // Once landed, animate towards target position (assembly)
                        if (!p.userData.assembling) {
                            p.userData.assembling = true;
                            p.userData.assembleStart = p.position.clone();
                            p.userData.assembleTime = 0;
                        }
                        p.userData.assembleTime += delta;
                        const assembleProgress = Math.min(p.userData.assembleTime / 1.5, 1.0);
                        const ease = 1 - Math.pow(1 - assembleProgress, 3);
                        p.position.lerpVectors(p.userData.assembleStart, p.userData.targetPos, ease);
                    }
                }
                
                // Camera follows the main body falling
                camera.position.set(player.position.x + Math.sin(time*0.5)*10, player.position.y + 6, player.position.z + Math.cos(time*0.5)*10);
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
                
                if (allLanded && progress >= 0.9) { 
                    player.isSpawning = false; 
                    document.body.classList.remove('spawning');
                    pm.group.visible = !isFirstPerson; 
                    if(isFirstPerson) document.getElementById('crosshair').classList.add('visible');
                    player.yaw = Math.PI; player.pitch = 0;
                    // Reset camera rotation to prevent slant after spawn
                    camera.rotation.set(0, 0, 0);
                }
                return; 
            }

            const isSprinting = (keys['ShiftLeft'] || keys['ShiftRight']);
            const speed = CONFIG.playerSpeed * (isSprinting ? CONFIG.sprintMultiplier : 1);
            camera.fov = THREE.MathUtils.lerp(camera.fov, (isSprinting && (keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'])) ? 90 : 75, 0.1);
            camera.updateProjectionMatrix();

            let mx = 0, mz = 0;
            if (keys['KeyW']) { mx -= Math.sin(player.yaw); mz -= Math.cos(player.yaw); }
            if (keys['KeyS']) { mx += Math.sin(player.yaw); mz += Math.cos(player.yaw); }
            if (keys['KeyA']) { mx -= Math.cos(player.yaw); mz += Math.sin(player.yaw); }
            if (keys['KeyD']) { mx += Math.cos(player.yaw); mz -= Math.sin(player.yaw); }
            
            const len = Math.sqrt(mx*mx + mz*mz);
            if (len > 0) { mx /= len; mz /= len; }

            const newX = player.position.x + mx * speed * delta;
            const newZ = player.position.z + mz * speed * delta;
            
            getActiveColliders(player.position.x, player.position.z);

            // Pass Y to collision to allow jumping OVER rocks
            if (!checkCollision(newX, player.position.y, player.position.z)) player.position.x = newX;
            if (!checkCollision(player.position.x, player.position.y, newZ)) player.position.z = newZ;

            if (keys['Space'] && player.onGround) { player.velocity.y = CONFIG.jumpForce; player.onGround = false; }
            player.velocity.y += CONFIG.gravity * delta; 
            player.position.y += player.velocity.y * delta;

            // Calculate floor height. Includes Rocks!
            let groundY = getTerrainHeight(player.position.x, player.position.z);
            for (let c of activeColliders) {
                if ((player.position.x - c.x)**2 + (player.position.z - c.z)**2 < (c.radius + CONFIG.playerRadius)**2) {
                    groundY = Math.max(groundY, c.y + c.height);
                }
            }
            
            const waterSurface = CONFIG.waterLevel - 0.5;
            const minH = Math.max(groundY, waterSurface);
            
            if (player.position.y < minH + CONFIG.playerHeight) {
                player.position.y = minH + CONFIG.playerHeight;
                player.velocity.y = 0; player.onGround = true;
            }

            if (player.onGround && len > 0) {
                player.walkCycle += delta * (isSprinting ? 15 : 10);
                player.bobAmount = THREE.MathUtils.lerp(player.bobAmount, isSprinting ? 0.2 : 0.1, 0.1);
            } else { 
                player.walkCycle = 0; player.bobAmount = THREE.MathUtils.lerp(player.bobAmount, 0, 0.1); 
            }

            const pm = playerModelData;
            pm.group.position.copy(player.position); pm.group.position.y -= CONFIG.playerHeight * 0.9; pm.group.rotation.y = player.yaw;
            const swing = Math.sin(player.walkCycle);
            pm.parts.leftLeg.rotation.x = swing * 0.8; pm.parts.rightLeg.rotation.x = -swing * 0.8;
            pm.parts.leftArm.rotation.x = -swing * 0.8; pm.parts.rightArm.rotation.x = swing * 0.8;

            document.getElementById('coords').textContent = `X: ${Math.floor(player.position.x)} | Z: ${Math.floor(player.position.z)}`;
            
            // Update compass
            const compassNeedle = document.getElementById('compassNeedle');
            if (compassNeedle) {
                compassNeedle.style.transform = `translateX(-50%) rotate(${-player.yaw * 180 / Math.PI}deg)`;
            }
        }

        function updateCamera(time) {
            if (player.isSpawning) {
                camera.position.set(player.position.x + Math.sin(time)*8, player.position.y + 4, player.position.z + Math.cos(time)*8);
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
            } else if (isFirstPerson) {
                // Head bob
                const bobSpeed = player.isSprinting ? 12 : 8;
                const bobAmount = player.isSprinting ? 0.15 : 0.08;
                const walkBob = Math.sin(time * bobSpeed) * bobAmount;
                const strafeBob = Math.cos(time * bobSpeed * 0.5) * bobAmount * 0.5;
                
                camera.position.copy(player.position);
                camera.position.y += Math.sin(player.walkCycle) * player.bobAmount + walkBob;
                camera.position.x += strafeBob;
                
                // Camera tilt while turning
                const turnSpeed = player.yaw - (player.prevYaw || player.yaw);
                const targetTilt = THREE.MathUtils.clamp(turnSpeed * 15, -0.15, 0.15);
                player.cameraTilt = THREE.MathUtils.lerp(player.cameraTilt || 0, targetTilt, 0.1);
                
                camera.rotation.order = 'YXZ'; 
                camera.rotation.y = player.yaw; 
                camera.rotation.x = player.pitch;
                camera.rotation.z = -player.cameraTilt;
                
                // Store previous yaw
                player.prevYaw = player.yaw;
            } else {
                const dist = 6, height = 2.5;
                camera.position.set(player.position.x + Math.sin(player.yaw) * dist, player.position.y + height, player.position.z + Math.cos(player.yaw) * dist);
                camera.lookAt(player.position.x, player.position.y, player.position.z);
            }
        }

        function updateMobs(delta) {
            const sunFactor = scene.userData.sunFactor || 0.5;
            const isNight = sunFactor < 0.3;
            
            for (const mob of mobs) {
                const distToPlayer = Math.sqrt((mob.mesh.position.x - player.position.x)**2 + (mob.mesh.position.z - player.position.z)**2);
                
                // Respawn far away if too close to player
                if (distToPlayer > 150) {
                    const angle = Math.random() * Math.PI * 2;
                    mob.mesh.position.x = player.position.x + Math.sin(angle) * 120; mob.mesh.position.z = player.position.z + Math.cos(angle) * 120;
                }
                
                // Animals sleep at night - reduce movement
                if (isNight && mob.type !== 'bear') {
                    mob.stateTimer = 10; // Long idle time at night
                    continue;
                }
                
                // Flee behavior for deer when player is close
                if (mob.type === 'deer' && distToPlayer < 20) {
                    const fleeAngle = Math.atan2(mob.mesh.position.x - player.position.x, mob.mesh.position.z - player.position.z);
                    mob.targetAngle = fleeAngle;
                    mob.speed = 8; // Faster when fleeing
                } else if (mob.type === 'bear') {
                    mob.speed = 2; // Bears move slowly
                } else if (mob.type === 'fox') {
                    mob.speed = 5; // Foxes are moderately fast
                } else {
                    mob.speed = 4; // Normal speed
                }
                
                mob.stateTimer -= delta;
                if (mob.stateTimer <= 0) { 
                    mob.targetAngle = Math.random() * Math.PI * 2; 
                    mob.stateTimer = 2 + Math.random() * 4; 
                }
                const angleDiff = THREE.MathUtils.euclideanModulo(mob.targetAngle - mob.mesh.rotation.y + Math.PI, Math.PI * 2) - Math.PI;
                mob.mesh.rotation.y += THREE.MathUtils.clamp(angleDiff, -0.1, 0.1);
                
                const nx = mob.mesh.position.x + Math.sin(mob.mesh.rotation.y) * mob.speed * delta;
                const nz = mob.mesh.position.z + Math.cos(mob.mesh.rotation.y) * mob.speed * delta;
                const ny = getTerrainHeight(nx, nz);
                if (ny > CONFIG.waterLevel) {
                    mob.mesh.position.set(nx, ny + 0.1, nz); mob.walkCycle += delta * 10;
                    const swing = Math.sin(mob.walkCycle) * 0.5;
                    mob.legs[0].rotation.x = swing; mob.legs[1].rotation.x = -swing; mob.legs[2].rotation.x = -swing; mob.legs[3].rotation.x = swing;
                } else { mob.targetAngle += Math.PI; }
            }
        }

        function initMinimap() { minimapCtx = document.getElementById('minimap-canvas').getContext('2d'); }
        function updateMinimap() {
            if (!minimapCtx) return; const ctx = minimapCtx; const size = 150; const scale = 1.0;
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(size/2, size/2, 4, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#7fdb8a'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(size/2, size/2);
            ctx.lineTo(size/2 - Math.sin(player.yaw) * 15, size/2 - Math.cos(player.yaw) * 15); ctx.stroke();
            ctx.fillStyle = '#f87171';
            for (const mob of mobs) {
                const mx = size/2 + (mob.mesh.position.x - player.position.x) * scale;
                const mz = size/2 + (mob.mesh.position.z - player.position.z) * scale;
                if (mx > 0 && mx < size && mz > 0 && mz < size) { ctx.beginPath(); ctx.arc(mx, mz, 2, 0, Math.PI * 2); ctx.fill(); }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();
            
            updateChunks(); 
            updateEnvironment(time); 
            updateWeather(time, delta);

            if (isPointerLocked) updatePlayer(delta, time);
            updateCamera(time);
            if (isCinematicMode) updateCinematicCamera(time, delta);
            updateMobs(delta);
            if (!player.isSpawning) updateMinimap();
            
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
